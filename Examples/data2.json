{"Prompt": "fun jar(name: String)", "Completion": "= lazy {\n        File(libPath, name).apply {\n            if (!exists()) {\n                throw IllegalStateException(\"File is not found in the directory of Kotlin Ant task: $name\")\n            }\n        }\n    }\n"}
{"Prompt": "fun getOrCreateClassLoader(): ClassLoader", "Completion": "{\n        val cached = classLoaderRef.get()\n        if (cached != null) return cached\n\n        val myLoader = this::class.java.classLoader\n        if (myLoader !is AntClassLoader) return myLoader\n\n        val classLoader = ClassPreloadingUtils.preloadClasses(listOf(compilerJar), Preloader.DEFAULT_CLASS_NUMBER_ESTIMATE, myLoader, null)\n        classLoaderRef = SoftReference(classLoader)\n\n        return classLoader\n    }\n"}
{"Prompt": "fun createLibraries(): Path", "Completion": "{\n        val libraryPaths = libraries ?: return Path(getProject()).also { libraries = it }\n        return libraryPaths.createPath()\n    }\n"}
{"Prompt": "fun fillSpecificArguments()", "Completion": "{\n        args.add(\"-output\")\n        args.add(output!!.canonicalPath)\n\n        // TODO: write test\n        libraries?.let {\n            args.add(\"-libraries\")\n            args.add(it.list().joinToString(File.pathSeparator) { File(it).canonicalPath })\n        }\n\n        outputPrefix?.let {\n            args.add(\"-output-prefix\")\n            args.add(it.canonicalPath)\n        }\n\n        outputPostfix?.let {\n            args.add(\"-output-postfix\")\n            args.add(it.canonicalPath)\n        }\n\n        main?.let {\n            args.add(\"-main\")\n            args.add(it)\n        }\n\n        if (noStdlib) args.add(\"-no-stdlib\")\n        if (sourceMap) args.add(\"-source-map\")\n        if (metaInfo) args.add(\"-meta-info\")\n\n        args += listOf(\"-module-kind\", moduleKind)\n    }\n"}
{"Prompt": "fun createSrc(): Path", "Completion": "{\n        val srcPath = src\n        if (srcPath == null) {\n            val t = Path(getProject())\n            src = t\n            return t\n        }\n\n        return srcPath.createPath()\n    }\n"}
{"Prompt": "fun setSrcRef(ref: Reference)", "Completion": "{\n        createSrc().refid = ref\n    }\n"}
{"Prompt": "fun createCompilerArg(): Commandline.Argument", "Completion": "{\n        val argument = Commandline.Argument()\n        additionalArguments.add(argument)\n        return argument\n    }\n"}
{"Prompt": "fun fillArguments()", "Completion": "{\n        val sourcePaths = src ?: throw BuildException(\"\\\"src\\\" should be specified\")\n        args.addAll(sourcePaths.list().map { File(it).canonicalPath })\n\n        output ?: throw BuildException(\"\\\"output\\\" should be specified\")\n\n        if (nowarn) args.add(\"-nowarn\")\n        if (verbose) args.add(\"-verbose\")\n        if (printVersion) args.add(\"-version\")\n\n        args.addAll(additionalArguments.flatMap { it.parts.toList() })\n\n        fillSpecificArguments()\n    }\n"}
{"Prompt": "fun execute()", "Completion": "{\n        fillArguments()\n\n        val compilerClass = KotlinAntTaskUtil.getOrCreateClassLoader().loadClass(compilerFqName)\n        val compiler = compilerClass.newInstance()\n        val exec = compilerClass.getMethod(\"execFullPathsInMessages\", PrintStream::class.java, Array<String>::class.java)\n\n        log(\"Compiling ${src!!.list().toList()} => [${output!!.canonicalPath}]\")\n\n        val result = exec(compiler, System.err, args.toTypedArray())\n        exitCode = (result as Enum<*>).ordinal\n\n        if (failOnError && exitCode != 0) {\n            throw BuildException(\"Compile failed; see the compiler error output for details.\")\n        }\n    }\n"}
{"Prompt": "fun setClasspath(classpath: Path)", "Completion": "{\n        if (compileClasspath == null) {\n            compileClasspath = classpath\n        }\n        else {\n            compileClasspath!!.append(classpath)\n        }\n    }\n"}
{"Prompt": "fun setClasspathRef(ref: Reference)", "Completion": "{\n        if (compileClasspath == null) {\n            compileClasspath = Path(getProject())\n        }\n        compileClasspath!!.createPath().refid = ref\n    }\n"}
{"Prompt": "fun addConfiguredClasspath(classpath: Path)", "Completion": "{\n        setClasspath(classpath)\n    }\n"}
{"Prompt": "fun fillSpecificArguments()", "Completion": "{\n        args.add(\"-d\")\n        args.add(output!!.canonicalPath)\n\n        compileClasspath?.let {\n            args.add(\"-classpath\")\n            args.add(it.list().joinToString(pathSeparator))\n        }\n\n\n        if (moduleName == null) {\n            moduleName = defaultModuleName\n        }\n\n        moduleName?.let {\n            args.add(\"-module-name\")\n            args.add(moduleName!!)\n        }\n\n        if (noStdlib) args.add(\"-no-stdlib\")\n        if (noReflect) args.add(\"-no-reflect\")\n        if (includeRuntime) args.add(\"-include-runtime\")\n    }\n"}
{"Prompt": "fun execute()", "Completion": "{\n        if (!fork)\n            super.execute()\n        else {\n            exec()\n        }\n    }\n"}
{"Prompt": "fun exec()", "Completion": "{\n        val javaHome = System.getProperty(\"java.home\")\n        val javaBin = javaHome + separator + \"bin\" + separator + \"java\"\n        val redirector = Redirector(this)\n\n        fillArguments()\n\n        val command = ArrayList<String>()\n        command.add(javaBin)\n        command.addAll(cmdl.vmCommand.arguments) // jvm args\n        command.add(\"-Dorg.jetbrains.kotlin.cliMessageRenderer=FullPath\") // same MessageRenderer as non-forking mode\n        command.add(\"-cp\")\n        command.add(KotlinAntTaskUtil.compilerJar.canonicalPath)\n        command.add(compilerFqName)\n        command.addAll(args) // compiler args\n\n        // streamHandler: used to handle the input and output streams of the subprocess.\n        // watchdog: a watchdog for the subprocess or <code>null</code> to disable a timeout for the subprocess.\n        // TODO: support timeout for the subprocess\n        val exe = Execute(redirector.createHandler(), null)\n        exe.setAntRun(getProject())\n        exe.commandline = command.toTypedArray()\n        log(\"Executing command: ${command.joinToString(\" \")}\", LogLevel.DEBUG.level)\n        log(\"Compiling ${src!!.list().toList()} => [${output!!.canonicalPath}]\")\n        val exitCode = exe.execute()\n        redirector.complete()\n        if (failOnError && exitCode != 0) {\n            throw BuildException(\"Compile failed; see the compiler error output for details.\")\n        }\n    }\n"}
{"Prompt": "fun createJvmarg(): Commandline.Argument", "Completion": "{\n        return cmdl.createVmArgument()\n    }\n"}
{"Prompt": "fun createCompilerArg(): Commandline.Argument", "Completion": "{\n        val argument = Commandline.Argument()\n        additionalArguments.add(argument)\n        return argument\n    }\n"}
{"Prompt": "fun getSupportedFileExtensions(): Array<String>", "Completion": "= super.getSupportedFileExtensions() + KOTLIN_EXTENSIONS\n"}
{"Prompt": "fun execute(): Boolean", "Completion": "{\n        if (javac.isForkedJavac) {\n            javac.log(\"<withKotlin> task does not yet support the fork mode\", MSG_ERR)\n            return false\n        }\n\n        val javac = javac\n\n        checkAntVersion()\n\n        val kotlinc = Kotlin2JvmTask()\n        kotlinc.failOnError = javac.failonerror\n        kotlinc.output = javac.destdir\n\n        val classpath = javac.classpath\n        if (classpath != null) {\n            kotlinc.setClasspath(classpath)\n        }\n\n        // We use the provided src dir instead of compileList, because the latter is insane:\n        // it is constructed only of sources which are newer than classes with the same name\n        kotlinc.src = javac.srcdir\n\n        if (moduleName == null) {\n            moduleName = javac.defaultModuleName\n        }\n        kotlinc.moduleName = moduleName\n\n        kotlinc.additionalArguments.addAll(additionalArguments)\n\n        // Javac13#execute passes everything in compileList to javac, which doesn't recognize .kt files\n        val compileListForJavac = filterOutKotlinSources(compileList)\n\n        val hasKotlinFilesInSources = compileListForJavac.size < compileList.size\n\n        if (hasKotlinFilesInSources) {\n            kotlinc.execute()\n            if (kotlinc.exitCode != 0) {\n                // Don't run javac if failOnError = false and there were errors on Kotlin sources\n                return false\n            }\n        }\n        else {\n            // This is needed for addRuntimeToJavacClasspath, where kotlinc arguments will be used.\n            kotlinc.fillArguments()\n        }\n\n        javac.log(\"Running javac...\")\n\n        compileList = compileListForJavac\n\n        addRuntimeToJavacClasspath(kotlinc)\n\n        return compileList.isEmpty() || super.execute()\n    }\n"}
{"Prompt": "fun addRuntimeToJavacClasspath(kotlinc: Kotlin2JvmTask)", "Completion": "{\n        // If \"-no-stdlib\" (or \"-no-reflect\") was specified explicitly, probably the user also wanted the javac classpath to not have it\n        val addStdlib = \"-no-stdlib\" !in kotlinc.args\n        val addReflect = \"-no-reflect\" !in kotlinc.args\n\n        if (!addStdlib && !addReflect) return\n\n        if (compileClasspath == null) {\n            compileClasspath = Path(getProject())\n        }\n        if (addStdlib) {\n            compileClasspath.add(Path(getProject(), KotlinAntTaskUtil.runtimeJar.absolutePath))\n        }\n        // \"-no-stdlib\" implies \"-no-reflect\", see K2JVMCompiler.Companion.getClasspath\n        if (addReflect && addStdlib) {\n            compileClasspath.add(Path(getProject(), KotlinAntTaskUtil.reflectJar.absolutePath))\n        }\n    }\n"}
{"Prompt": "fun checkAntVersion()", "Completion": "{\n        val checkVersion = AntVersion()\n        checkVersion.atLeast = \"1.8.2\"\n        if (!checkVersion.eval()) {\n            javac.log(\"<withKotlin> task requires Ant of version at least 1.8.2 to operate reliably. \" +\n                      \"Please upgrade or, as a workaround, make sure you have at least one Java source and \" +\n                      \"the output directory is clean before running this task. \" +\n                      \"You have: \" + getProject().getProperty(MagicNames.ANT_VERSION), MSG_WARN)\n        }\n    }\n"}
{"Prompt": "fun filterOutKotlinSources(files: Array<File>): Array<File>", "Completion": "{\n            return files.filterNot {\n                for (extension in KOTLIN_EXTENSIONS) {\n                    if (it.path.endsWith(\".\" + extension)) return@filterNot true\n                }\n                false\n            }.toTypedArray()\n        }\n"}
{"Prompt": "fun String.jsId()", "Completion": "= ClassId(JsStandardClassIds.BASE_JS_PACKAGE, Name.identifier(this))\n"}
{"Prompt": "fun String.callableId(packageName: FqName)", "Completion": "= CallableId(packageName, Name.identifier(this))\n"}
{"Prompt": "fun doTest(fileName: String)", "Completion": "{\n        val file = File(fileName)\n        val text = FileUtil.loadFile(file, true)\n\n        if (InTextDirectivesUtils.isDirectiveDefined(text, \"SKIP_IN_RUNTIME_TEST\")) return\n\n        val jdkKind =\n            if (InTextDirectivesUtils.isDirectiveDefined(text, \"FULL_JDK\")) TestJdkKind.FULL_JDK\n            else defaultJdkKind\n\n        compileFile(file, text, jdkKind)\n\n        val classLoader = URLClassLoader(arrayOf(tmpdir.toURI().toURL()), ForTestCompileRuntime.runtimeAndReflectJarClassLoader())\n\n        val actual = createReflectedPackageView(classLoader)\n\n        val comparatorConfiguration = Configuration(\n            /* checkPrimaryConstructors = */ fileName.endsWith(\".kt\"),\n            /* checkPropertyAccessors = */ true,\n            /* includeMethodsOfKotlinAny = */ false,\n            /* renderDeclarationsFromOtherModules = */ true,\n            /* checkFunctionContract = */ false,\n            // Skip Java annotation constructors because order of their parameters is not retained at runtime\n            { descriptor -> !descriptor!!.isJavaAnnotationConstructor() },\n            errorTypesForbidden(), renderer\n        )\n\n        val differentResultFile = KotlinTestUtils.replaceExtension(file, \"runtime.txt\")\n        if (differentResultFile.exists()) {\n            RecursiveDescriptorComparatorAdaptor.validateAndCompareDescriptorWithFile(actual, comparatorConfiguration, differentResultFile)\n            return\n        }\n\n        val expected = LoadDescriptorUtil.loadTestPackageAndBindingContextFromJavaRoot(\n            tmpdir, testRootDisposable, jdkKind, ConfigurationKind.ALL, true, false, false, false, null\n        ).first\n\n        RecursiveDescriptorComparatorAdaptor.validateAndCompareDescriptors(expected, actual, comparatorConfiguration, null)\n    }\n"}
{"Prompt": "fun DeclarationDescriptor.isJavaAnnotationConstructor()", "Completion": "=\n"}
{"Prompt": "fun compileFile(file: File, text: String, jdkKind: TestJdkKind)", "Completion": "{\n        val fileName = file.name\n        when {\n            fileName.endsWith(\".java\") -> {\n                val sources = TestFiles.createTestFiles(\n                    fileName,\n                    text,\n                    object : TestFileFactoryNoModules<File>() {\n                        override fun create(fileName: String, text: String, directives: Directives): File {\n                            val targetFile = File(tmpdir, fileName)\n                            targetFile.writeText(adaptJavaSource(text))\n                            return targetFile\n                        }\n                    }\n                )\n                LoadDescriptorUtil.compileJavaWithAnnotationsJar(sources, tmpdir, emptyList(), null, false)\n            }\n            fileName.endsWith(\".kt\") -> {\n                val environment = KotlinTestUtils.createEnvironmentWithJdkAndNullabilityAnnotationsFromIdea(\n                    testRootDisposable, ConfigurationKind.ALL, jdkKind\n                )\n\n                AbstractLoadJavaTest.updateConfigurationWithDirectives(file.readText(), environment.configuration)\n\n                for (root in environment.configuration.getList(CLIConfigurationKeys.CONTENT_ROOTS)) {\n                    LOG.info(\"root: $root\")\n                }\n                val ktFile = KtTestUtil.createFile(file.path, text, environment.project)\n                GenerationUtils.compileFileTo(ktFile, environment, tmpdir)\n            }\n        }\n    }\n"}
{"Prompt": "fun createReflectedPackageView(classLoader: URLClassLoader): SyntheticPackageViewForTest", "Completion": "{\n        val moduleData = RuntimeModuleData.create(classLoader)\n        val module = moduleData.module\n\n        val generatedPackageDir = File(tmpdir, LoadDescriptorUtil.TEST_PACKAGE_FQNAME.pathSegments().single().asString())\n        val allClassFiles = FileUtil.findFilesByMask(Pattern.compile(\".*\\\\.class\"), generatedPackageDir)\n\n        val packageScopes = arrayListOf<MemberScope>()\n        val classes = arrayListOf<ClassDescriptor>()\n        for (classFile in allClassFiles) {\n            val className = classFile.toRelativeString(tmpdir).substringBeforeLast(\".class\").replace('/', '.').replace('\\\\', '.')\n\n            val klass = classLoader.loadClass(className).sure { \"Couldn't load class $className\" }\n            val binaryClass = ReflectKotlinClass.create(klass)\n            val header = binaryClass?.classHeader\n\n            if (header?.kind == KotlinClassHeader.Kind.FILE_FACADE || header?.kind == KotlinClassHeader.Kind.MULTIFILE_CLASS) {\n                packageScopes.add(moduleData.packagePartScopeCache.getPackagePartScope(binaryClass))\n            } else if (header == null || header.kind == KotlinClassHeader.Kind.CLASS) {\n                // Either a normal Kotlin class or a Java class\n                val classId = klass.classId\n                if (!classId.isLocal) {\n                    val classDescriptor = module.findClassAcrossModuleDependencies(classId).sure { \"Couldn't resolve class $className\" }\n                    if (DescriptorUtils.isTopLevelDeclaration(classDescriptor)) {\n                        classes.add(classDescriptor)\n                    }\n                }\n            }\n        }\n\n        // Since runtime package view descriptor doesn't support getAllDescriptors(), we construct a synthetic package view here.\n        // It has in its scope descriptors for all the classes and top level members generated by the compiler\n        return SyntheticPackageViewForTest(module, packageScopes, classes)\n    }\n"}
{"Prompt": "fun adaptJavaSource(text: String): String", "Completion": "{\n        val typeAnnotations = arrayOf(\"NotNull\", \"Nullable\", \"ReadOnly\", \"Mutable\")\n        val adaptedSource = typeAnnotations.fold(text) { result, annotation -> result.replace(\"@$annotation\", \"\") }\n        if (\"@Retention\" !in adaptedSource) {\n            return adaptedSource.replace(\n                \"@interface\",\n                \"@java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME) @interface\"\n            )\n        }\n        return adaptedSource\n    }\n"}
{"Prompt": "fun getMemberScope(): MemberScope", "Completion": "= scope\n"}
{"Prompt": "fun <R, D> accept(visitor: DeclarationDescriptorVisitor<R, D>, data: D): R", "Completion": "=\n"}
{"Prompt": "fun getContainingDeclaration(): PackageViewDescriptor?", "Completion": "= null\n"}
{"Prompt": "fun getOriginal()", "Completion": "= throw UnsupportedOperationException()\n"}
{"Prompt": "fun acceptVoid(visitor: DeclarationDescriptorVisitor<Void, Void>?)", "Completion": "= throw UnsupportedOperationException()\n"}
{"Prompt": "fun getName()", "Completion": "= throw UnsupportedOperationException()\n"}
{"Prompt": "fun getContributedClassifier(name: Name, location: LookupLocation): ClassifierDescriptor?", "Completion": "= classifierMap[name]\n"}
{"Prompt": "fun getContributedDescriptors(\n            kindFilter: DescriptorKindFilter,\n            nameFilter: (Name) -> Boolean\n        ): Collection<DeclarationDescriptor>", "Completion": "= classifierMap.values\n"}
{"Prompt": "fun printScopeStructure(p: Printer)", "Completion": "{\n            p.println(\"runtime descriptor loader test\")\n        }\n"}
{"Prompt": "fun main(args: Array<String>)", "Completion": "{\n    System.setProperty(\"java.awt.headless\", \"true\")\n\n    generateTestGroupSuite(args) {\n        testGroup(\"core/descriptors.runtime/tests\", \"compiler/testData\") {\n            testClass<AbstractJvmRuntimeDescriptorLoaderTest> {\n                model(\"loadJava/compiledKotlin\")\n                model(\"loadJava/compiledJava\", extension = \"java\", excludeDirs = listOf(\"sam\", \"kotlinSignature/propagation\"))\n            }\n\n            testClass<AbstractJvm8RuntimeDescriptorLoaderTest> {\n                model(\"loadJava8/compiledJava\", extension = \"java\")\n            }\n        }\n    }\n}\n"}
{"Prompt": "fun getPackagePartScope(fileClass: ReflectKotlinClass): MemberScope", "Completion": "= cache.getOrPut(fileClass.classId) {\n        val fqName = fileClass.classId.packageFqName\n\n        val parts =\n            if (fileClass.classHeader.kind == KotlinClassHeader.Kind.MULTIFILE_CLASS)\n                fileClass.classHeader.multifilePartNames.mapNotNull { partName ->\n                    val classId = ClassId.topLevel(JvmClassName.byInternalName(partName).fqNameForTopLevelClassMaybeWithDollars)\n                    kotlinClassFinder.findKotlinClass(classId, resolver.components.configuration.jvmMetadataVersionOrDefault())\n                }\n            else listOf(fileClass)\n\n        val packageFragment = EmptyPackageFragmentDescriptor(resolver.components.moduleDescriptor, fqName)\n\n        val scopes = parts.mapNotNull { part ->\n            resolver.createKotlinPackagePartScope(packageFragment, part)\n        }.toList()\n\n        ChainedMemberScope.create(\"package $fqName ($fileClass)\", scopes)\n    }\n"}
{"Prompt": "fun create(classLoader: ClassLoader): RuntimeModuleData", "Completion": "{\n            val kotlinClassFinder = ReflectKotlinClassFinder(classLoader)\n            val moduleData = createModuleData(\n                kotlinClassFinder = kotlinClassFinder,\n                // .kotlin_builtins files should be found by the same class loader that loaded stdlib classes\n                jvmBuiltInsKotlinClassFinder = ReflectKotlinClassFinder(Unit::class.java.classLoader),\n                javaClassFinder = ReflectJavaClassFinder(classLoader),\n                moduleName = \"runtime module for $classLoader\",\n                errorReporter = RuntimeErrorReporter,\n                javaSourceElementFactory = RuntimeSourceElementFactory\n            )\n            return RuntimeModuleData(\n                moduleData.deserializationComponentsForJava.components,\n                PackagePartScopeCache(moduleData.deserializedDescriptorResolver, kotlinClassFinder)\n            )\n        }\n"}